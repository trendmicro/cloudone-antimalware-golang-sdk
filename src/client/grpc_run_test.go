package client

import (
	"errors"
	"github.com/stretchr/testify/assert"
	pb "github.com/trendmicro/amaas/client/base"
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"math/rand"
	"os"
	"testing"
)

/***************************************************************************

One of the most critical functional areas for us to test with the AMaaS
client is that given a command from the server, the client will actually
carry out the task requested by the server, namely, retrieving the right
data chunk from the file when requested by the server.

***************************************************************************/

// This class will generate a temporary file with consecutive sequences of
// extended ASCII codes from 0 to 255 in ascending order, where each code
// occupies one (1) byte. For example, a file that is exactly 256 bytes long
// would be [0x00, 0x01, 0x02, ... , 0xFD, 0xFE, 0xFF] while a file that is
// exactly 512 bytes long would be [0x00, 0x01, 0x02, ... , 0xFD, 0xFE, 0xFF,
// 0x00, 0x01, 0x02, ... , 0xFD, 0xFE, 0xFF].

const (
	EnvVarTestDatDir      = "AMAAS_UNIT_TEST_GOLANG_DIR"
	DefaultTestDatDirPath = "."
	MaxFileSize           = 1 << 20
	MaxChunkReadSize      = 1 << 12
	NumReadIterations     = 1 << 14
)

type TestDat struct {
	filesize int
	filename string
}

func createTestDat(fnameTemplate string) *TestDat {

	tempDir := os.Getenv(EnvVarTestDatDir)
	if tempDir == "" {
		tempDir = DefaultTestDatDirPath
	}

	file, err := os.CreateTemp(tempDir, fnameTemplate)
	if err != nil {
		return nil
	}

	d := &TestDat{
		filesize: MaxFileSize,
		filename: file.Name(),
	}

	fd, err := os.Create(d.filename)
	if err != nil {
		return nil
	}
	defer fd.Close()

	b := make([]byte, d.filesize)
	for i := 0; i < d.filesize; i++ {
		b[i] = byte(i % 256)
	}

	if n, err := fd.Write(b); err != nil || n != d.filesize {
		return nil
	}

	return d
}

func (d *TestDat) ExpectedValueAt(pos int) byte {
	return byte(pos % 256)
}

func (d *TestDat) Filename() string {
	return d.filename
}

func (d *TestDat) Filesize() int {
	return d.filesize
}

// Test readFileBytes() function which is critical to client retrieval
// of file content.

func TestReadFileBytes(t *testing.T) {

	dat := createTestDat("test.*.dat")
	defer os.Remove(dat.Filename())

	f, err := os.Open(dat.Filename())
	assert.Nil(t, err)
	defer f.Close()

	fi, err := os.Stat(dat.Filename())
	assert.Nil(t, err)

	fileSize := int(fi.Size())

	for i := 0; i < NumReadIterations; i++ {
		offset := rand.Intn(fileSize)
		len := rand.Intn(MaxChunkReadSize) + 1
		end := offset + len
		if end > fileSize {
			len -= (end - fileSize)
		}

		pbuf, err := readFileBytes(f, int64(offset), int32(len))
		assert.Nil(t, err)
		assert.NotNil(t, pbuf)

		for j := 0; j < len; j++ {
			expected := dat.ExpectedValueAt(offset + j)
			result := (*pbuf)[j]
			assert.Equal(t, expected, result)
		}
	}
}

// Mock client stream for testing
// Essentially we're using channel here to simulate flow of commands/replies
// from the server to the client (response messages per RPC convention), and
// from client to the server (request messages per RPC convention).
//
// In the case of AMaaS client-server design, it's actually the server
// issuing commands to the client using S2C messages, and the client reading
// data chunks off the file and sending them back to the server using C2S
// messages.

type ClientStreamMock struct {
	grpc.ClientStream
	recvToClient   chan *pb.S2C
	sentFromClient chan *pb.C2S
}

func createClientStreamMock() *ClientStreamMock {
	return &ClientStreamMock{
		recvToClient:   make(chan *pb.S2C, NumReadIterations),
		sentFromClient: make(chan *pb.C2S, NumReadIterations),
	}
}

func (mock *ClientStreamMock) Send(req *pb.C2S) error {
	mock.sentFromClient <- req
	return nil
}

func (mock *ClientStreamMock) Recv() (*pb.S2C, error) {

	resp, more := <-mock.recvToClient
	if !more {
		return nil,
			errors.New("Simulated stream is now empty of server2client responses")
	}
	return resp, nil
}

func (mock *ClientStreamMock) SendFromServer(resp *pb.S2C) error {
	mock.recvToClient <- resp
	return nil
}

func (mock *ClientStreamMock) RecvToServer() (*pb.C2S, error) {
	req, more := <-mock.sentFromClient
	if !more {
		return nil,
			errors.New("Simulated stream is now empty of client2server requests")
	}
	return req, nil
}

// Test gRPC client runUploadLoop() function to make sure it processes the
// RETR commands from the server correctly.
//
// Also some testing of abnormal conditions, but more unit tests will be
// added to make sure the loop handles all sorts of different abnormal
// conditions later on.
//

// Global channel for storing errors generated by runUploadLoop(). Depending
// on the testcase, this channel might be completely empty or containing
// some error.

var errChan chan error = make(chan error, NumReadIterations)

func createMockClientRun(t *testing.T, fd *os.File) *ClientStreamMock {

	stream := createClientStreamMock()

	go func() {
		_, _, err := runUploadLoop(stream, fd)
		if err != nil {
			errChan <- err
		}
		close(stream.sentFromClient)
		close(stream.recvToClient)
	}()

	return stream
}

// Test normal read conditions where client receives all valid
// S2C messages directing client to read from valid positions within
// the length of the file.

func TestRunUploadLoopNormal(t *testing.T) {

	dat := createTestDat("test.*.dat")
	assert.NotNil(t, dat)
	defer os.Remove(dat.Filename())

	fd, err := os.Open(dat.Filename())
	assert.Nil(t, err)
	defer fd.Close()

	stream := createMockClientRun(t, fd)
	assert.NotNil(t, stream)

	reads := make([](*pb.S2C), NumReadIterations)

	for i := 0; i < NumReadIterations; i++ {
		s2c := generateRetrS2C(dat.Filesize())
		assert.NotNil(t, s2c)

		err := stream.SendFromServer(s2c)
		assert.Nil(t, err)
		reads[i] = s2c
	}

	// No reason for runUploadLoop() to send any error into the
	// error channel. Something is wrong if non-empty.

	assert.Equal(t, 0, len(errChan))

	for i := 0; i < NumReadIterations; i++ {
		resp, err := stream.RecvToServer()
		assert.Nil(t, err)
		assert.NotNil(t, resp)

		verifyC2SResp(t, dat, reads[i], resp)
	}
}

func generateRetrS2C(fileSize int) *pb.S2C {
	offset := rand.Intn(fileSize)
	len := rand.Intn(MaxChunkReadSize) + 1
	end := offset + len
	if end > fileSize {
		len -= (end - fileSize)
	}

	return &pb.S2C{
		Stage:  pb.Stage_STAGE_RUN,
		Cmd:    pb.Command_CMD_RETR,
		Offset: int32(offset),
		Length: int32(len),
	}
}

func verifyC2SResp(t *testing.T, dat *TestDat, req *pb.S2C, resp *pb.C2S) {
	assert.Equal(t, pb.Stage_STAGE_RUN, resp.Stage)
	assert.Equal(t, req.Offset, resp.Offset)

	origLen := int(req.Length)
	assert.Equal(t, origLen, len(resp.Chunk))

	for i := 0; i < origLen; i++ {
		assert.Equal(t, dat.ExpectedValueAt(int(req.Offset)+i), resp.Chunk[i])
	}
}

// Test condition where the file descriptor for the file to be read is
// actually invalid. So it generate an internal error upon runUploadLoop()
// receiving a command to read the file.

func TestRunUploadLoopBadFd(t *testing.T) {

	var badFd *os.File = nil

	stream := createMockClientRun(t, badFd)
	assert.NotNil(t, stream)

	s2c := generateRetrS2C(10)
	assert.NotNil(t, s2c)

	err := stream.SendFromServer(s2c)
	assert.Nil(t, err)

	// runUploadLoop() should have sent 1 error into the channel.
	err = <-errChan
	assert.NotNil(t, err)

	st, _ := status.FromError(err)
	assert.Equal(t, codes.Internal, st.Code())

	// There should be no C2S message sent by the client into the
	// simulated message channel due to error carrying out the task
	// dictated by the S2C command, so trying to read from the message
	// channel should result in an error.

	_, err = stream.RecvToServer()
	assert.NotNil(t, err)
}

// Test situation where the client actually receives an invalid RETR
// S2C message where the offset to read from is actually beyond the
// end of the file.

func TestRunUploadLoopBadRetrOffset(t *testing.T) {

	dat := createTestDat("test.*.dat")
	assert.NotNil(t, dat)
	defer os.Remove(dat.Filename())

	fd, err := os.Open(dat.Filename())
	assert.Nil(t, err)
	defer fd.Close()

	stream := createMockClientRun(t, fd)
	assert.NotNil(t, stream)

	s2c := &pb.S2C{
		Stage:  pb.Stage_STAGE_RUN,
		Cmd:    pb.Command_CMD_RETR,
		Offset: int32(dat.Filesize()) * 2,
		Length: int32(1),
	}

	err = stream.SendFromServer(s2c)
	assert.Nil(t, err)

	// runUploadLoop() should have sent 1 error into the channel due
	// to S2C message directing the client to read at an offset beyond
	// the end of the file.
	err = <-errChan
	assert.NotNil(t, err)

	st, _ := status.FromError(err)
	assert.Equal(t, codes.Internal, st.Code())

	// There should be no C2S message sent by the client into the
	// simulated message channel, so trying to read from the message
	// channel should result in an error.

	_, err = stream.RecvToServer()
	assert.NotNil(t, err)
}

// Test situation where the client actually receives an invalid RETR
// S2C message where the length to read from the offset would have the
// client reading past EOF.

func TestRunUploadLoopBadRetrLength(t *testing.T) {

	dat := createTestDat("test.*.dat")
	assert.NotNil(t, dat)
	defer os.Remove(dat.Filename())

	fd, err := os.Open(dat.Filename())
	assert.Nil(t, err)
	defer fd.Close()

	stream := createMockClientRun(t, fd)
	assert.NotNil(t, stream)

	s2c := &pb.S2C{
		Stage:  pb.Stage_STAGE_RUN,
		Cmd:    pb.Command_CMD_RETR,
		Offset: int32(dat.Filesize() - 1),
		Length: int32(1024),
	}

	err = stream.SendFromServer(s2c)
	assert.Nil(t, err)

	// runUploadLoop() should have sent 1 error into the channel due
	// to S2C message directing the client to read at an offset beyond
	// the end of the file.
	err = <-errChan
	assert.NotNil(t, err)

	st, _ := status.FromError(err)
	assert.Equal(t, codes.Internal, st.Code())

	// There should be no C2S message sent by the client into the
	// simulated message channel, so trying to read from the message
	// channel should result in an error.

	_, err = stream.RecvToServer()
	assert.NotNil(t, err)
}

// Test condition where the S2C command to the client is simply
// some invalid garbage.

func TestRunUploadLoopBadS2CMsg(t *testing.T) {

	stream := createMockClientRun(t, nil)
	assert.NotNil(t, stream)

	s2c := &pb.S2C{
		Stage:  pb.Stage(100),
		Cmd:    pb.Command(200),
		Offset: 0,
		Length: 0,
	}

	err := stream.SendFromServer(s2c)
	assert.Nil(t, err)

	// runUploadLoop() should have sent 1 error into the channel due
	// to not able to interpret the received command message.
	err = <-errChan
	assert.NotNil(t, err)

	st, _ := status.FromError(err)
	assert.Equal(t, codes.Internal, st.Code())

	// There should be no C2S message sent by the client into the
	// simulated message channel, so trying to read from the message
	// channel should result in an error.

	_, err = stream.RecvToServer()
	assert.NotNil(t, err)
}

// Test condition where the S2C command to the client is simply
// some invalid message.

func TestRunUploadLoopBadRetrMsg(t *testing.T) {

	stream := createMockClientRun(t, nil)
	assert.NotNil(t, stream)

	s2c1 := &pb.S2C{
		Stage:  pb.Stage_STAGE_INIT,
		Cmd:    pb.Command_CMD_RETR,
		Offset: int32(0),
		Length: int32(0),
	}

	err := stream.SendFromServer(s2c1)
	assert.Nil(t, err)

	// runUploadLoop() should have sent 1 error into the channel due
	// to not able to interpret the received command message, due to
	// missing fields within the command message.

	err = <-errChan
	assert.NotNil(t, err)

	st, _ := status.FromError(err)
	assert.Equal(t, codes.Internal, st.Code())

	// There should be no C2S message sent by the client into the
	// simulated message channel, so trying to read from the message
	// channel should result in an error.

	_, err = stream.RecvToServer()
	assert.NotNil(t, err)
}
