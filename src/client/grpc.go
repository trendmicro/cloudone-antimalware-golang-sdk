package client

import (
	"context"
	"crypto/tls"
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"log"
	"os"
	"strconv"
	"strings"
	"time"

	pb "github.com/trendmicro/amaas/client/base"

	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/credentials"
	"google.golang.org/grpc/credentials/insecure"
	gmd "google.golang.org/grpc/metadata"
	"google.golang.org/grpc/status"
)

const (
	_envvarAuthKeyNotRequired = "TM_AM_AUTH_KEY_NOT_REQUIRED" // Set to 1 and Client SDK will not send auth key to server; set to 0 or leave empty to disable.
	_envvarServerAddr         = "TM_AM_SERVER_ADDR"           // <host FQDN>:<port no>
	_envvarDisableTLS         = "TM_AM_DISABLE_TLS"           // Set to 1 to not use TLS for client-server communication; set to 0 or leave empty otherwise.
	_envvarDisableCertVerify  = "TM_AM_DISABLE_CERT_VERIFY"   // Set to 1 to not disable server certificate check by client; set to 0 or leave empty otherwise.
)

type LogLevel int
type LoggerCallback func(level LogLevel, levelStr string, format string, a ...interface{})

var currentLogLevel LogLevel = LogLevelOff
var userLogger LoggerCallback = nil

///////////////////////////////////////
//
// AMaaS Client layer related functions
//
///////////////////////////////////////

type AmaasClient struct {
	conn        *grpc.ClientConn
	isC1Token   bool
	authKey     string
	addr        string
	useTLS      bool
	verifyCert  bool
	timeoutSecs int

	archHandler AmaasClientArchiveHandler
}

func fileScanRun(ctx context.Context, cancel context.CancelFunc, c pb.ScanClient, fileName string) (string, error) {

	defer cancel()

	fd, err := os.Open(fileName)

	if err != nil {
		logMsg(LogLevelError, "Cannot open file %s: %v", fileName, err)
		return makeFailedScanJSONResp(), err
	}
	defer fd.Close()

	fi, _ := os.Stat(fileName)

	var stream pb.Scan_RunClient

	// Where certificate and connections related checks first happen, so many different
	// error conditions can be returned here.

	if stream, err = c.Run(ctx); err != nil {
		logMsg(LogLevelError, "Failed to setup stream: %v", err)
		return makeFailedScanJSONResp(), sanitizeGRPCError(err)
	}

	defer stream.CloseSend()

	if err = runInitRequest(stream, fileName, int32(fi.Size())); err != nil {
		return makeFailedScanJSONResp(), err
	}

	var result string
	var totalUpload int32

	if result, totalUpload, err = runUploadLoop(stream, fd); err != nil {
		return makeFailedScanJSONResp(), err
	}

	logMsg(LogLevelDebug, "Uploaded %d bytes", totalUpload)

	return result, nil
}

func runInitRequest(stream pb.Scan_RunClient, fileName string, fileSize int32) error {

	if err := stream.Send(&pb.C2S{Stage: pb.Stage_STAGE_INIT,
		FileName: fileName, RsSize: fileSize}); err != nil {
		err = sanitizeGRPCError(err)
		logMsg(LogLevelError, "Failed to send init msg: %v", err)
		return err
	}

	return nil
}

func runUploadLoop(stream pb.Scan_RunClient, fd *os.File) (result string, totalUpload int32, overallErr error) {

	result = ""
	totalUpload = 0
	overallErr = nil

	for {
		in, err := stream.Recv()

		if err != nil {
			if err == io.EOF {
				logMsg(LogLevelDebug, "Server closed connection")

			} else {

				msg := fmt.Sprintf("Failed to recv: %v", err.Error())
				logMsg(LogLevelError, msg)
				overallErr = sanitizeGRPCError(err)
				return
			}
			break
		}

		// TBD: Might be useful to add some checks to make sure message stage
		// and command values are coherent. Within the runUploadLoop(), stage
		// should really just be STAGE_RUN.

		switch in.Cmd {

		case pb.Command_CMD_QUIT:

			logMsg(LogLevelDebug, "Received QUIT command, exiting...\n")
			result = in.Result
			return

		case pb.Command_CMD_RETR:

			logMsg(LogLevelDebug, "Received RETR command, offset: %d, length: %d", in.Offset, in.Length)

			totalUpload += in.Length

			if pbuf, err := readFileBytes(fd, int64(in.Offset), in.Length); err != nil {

				msg := fmt.Sprintf("Failed to retrieve data from file: %s", err.Error())
				logMsg(LogLevelError, msg)
				overallErr = makeInternalError(msg)
				return

			} else {

				if err := stream.Send(&pb.C2S{
					Stage:  pb.Stage_STAGE_RUN,
					Offset: in.Offset,
					Chunk:  *pbuf}); err != nil {

					msg := fmt.Sprintf("Failed to send data chunk: %s", err.Error())
					logMsg(LogLevelError, msg)
					overallErr = makeInternalError(msg)
					return
				}
			}

		default:

			msg := fmt.Sprintf("Received unknown command from server: %d", in.Cmd)
			logMsg(LogLevelError, msg)
			overallErr = makeInternalError(msg)
			return
		}
	}

	return
}

func readFileBytes(fd *os.File, offset int64, length int32) (*[]byte, error) {

	// TBD: Maybe this needs to be optimized a little to avoid allocation and more frequent
	// than optimal garbage collection. Need to do testing and profiling later on to see
	// this will be a performance hotspot.

	b := make([]byte, length)

	if retrLen, err := fd.ReadAt(b, offset); err == nil {
		if int32(retrLen) != length {
			msg := fmt.Sprintf("Attempted to read %d bytes but only retrieved %d", len(b), length)
			return nil, errors.New(msg)
		}
	} else {
		return nil, err
	}

	return &b, nil
}

func (ac *AmaasClient) fileScanRun(fileName string) (string, error) {

	if ac.conn == nil {
		return "", errors.New("client is not ready to carry out scans, possibly due to invocation of Destroy()")
	}

	if ac.archHandler.archHandlingEnabled() {
		return ac.archHandler.fileScanRun(fileName)
	}

	return ac.fileScanRunNormalFile(fileName)
}

func (ac *AmaasClient) fileScanRunNormalFile(fileName string) (string, error) {

	ctx, cancel := context.WithTimeout(context.Background(), time.Second*time.Duration(ac.timeoutSecs))

	if ac.authKey != "" {
		if ac.isC1Token {
			ctx = gmd.AppendToOutgoingContext(ctx, "Authorization", fmt.Sprintf("Bearer %s", ac.authKey))
		} else {
			ctx = gmd.AppendToOutgoingContext(ctx, "Authorization", fmt.Sprintf("ApiKey %s", ac.authKey))
		}
	}

	return fileScanRun(ctx, cancel, pb.NewScanClient(ac.conn), fileName)
}

func (ac *AmaasClient) setupComm() error {
	var err error

	if ac.authKey != "" {
		ac.isC1Token = isC1Token(ac.authKey)
	}

	if ac.conn == nil {
		if ac.useTLS {
			ac.conn, err = grpc.Dial(ac.addr, grpc.WithTransportCredentials(credentials.NewTLS(&tls.Config{InsecureSkipVerify: !ac.verifyCert})))
		} else {
			ac.conn, err = grpc.Dial(ac.addr, grpc.WithTransportCredentials(insecure.NewCredentials()))
		}

		if err != nil {
			return err
		}
	}

	return nil
}

////////////////////////////////////////////////
//
// Cloud One and client related helper functions
//
////////////////////////////////////////////////

func checkAuthKey(authKey string) (string, error) {

	envAuthKeyNotRequired := os.Getenv(_envvarAuthKeyNotRequired)

	if envAuthKeyNotRequired != "" && envAuthKeyNotRequired != "0" {
		return "", nil
	}

	var auth string = authKey

	envAuthKey := os.Getenv(_envvarAuthKey)

	if authKey == "" && envAuthKey == "" {
		return "", errors.New("must provide an API key to use the client")
	} else if envAuthKey != "" {
		auth = envAuthKey
	}

	isToken := isC1Token(auth)
	isKey := isC1APIKey(auth)

	if !isToken && !isKey {
		return "", errors.New("Invalid authorization key provided. Please provide a valid API key or token")
	} else if isToken && isKey {
		return "", errors.New("Internal error: unable to determine authorization key type")
	}

	return auth, nil
}

func isC1Token(auth string) bool {
	keySplitted := strings.Split(auth, ".")
	if len(keySplitted) != 3 { // The JWT should contain three parts
		return false
	}

	jsonFirstPart, err := base64.StdEncoding.DecodeString(keySplitted[0])
	if err != nil {
		return false
	}

	var firstPart struct {
		Alg string `json:"alg"`
	}
	err = json.Unmarshal(jsonFirstPart, &firstPart)
	if err != nil || firstPart.Alg == "" { // The first part should have the attribute "alg"
		return false
	}

	return true
}

func isC1APIKey(auth string) bool {
	return strings.HasPrefix(auth, "tmc")
}

func identifyServerAddr(region string) (string, error) {
	envOverrideAddr := os.Getenv(_envvarServerAddr)

	if envOverrideAddr != "" {
		return envOverrideAddr, nil
	}

	fqdn := getServiceFQDN(region)
	if fqdn == "" {
		return "", errors.New(region + " is not a valid region")
	}

	return fmt.Sprintf("%s:%d", fqdn, _defaultCommPort), nil
}

func retrieveTLSSettings() (useTLS bool, verifyCert bool) {
	envDisableTLS := os.Getenv(_envvarDisableTLS)
	envDisableCertVerify := os.Getenv(_envvarDisableCertVerify)

	return (envDisableTLS == "" || envDisableTLS == "0"), (envDisableCertVerify == "" || envDisableCertVerify == "0")
}

func getDefaultScanTimeout() (int, error) {
	envScanTimeoutSecs := os.Getenv(_envvarScanTimeoutSecs)

	if envScanTimeoutSecs != "" {
		if val, err := strconv.Atoi(envScanTimeoutSecs); err != nil {
			return 0, errors.New("cannot parse value specified by environment variable " + _envvarScanTimeoutSecs)
		} else {
			return val, nil
		}
	}

	return _defaultTimeoutSecs, nil
}

func getServiceFQDN(targetRegion string) string {

	const mappingJSON = `{
		"us-1": "antimalware.us-1.cloudone.trendmicro.com",
		"in-1": "antimalware.in-1.cloudone.trendmicro.com",
		"de-1": "antimalware.de-1.cloudone.trendmicro.com",
		"sg-1": "antimalware.sg-1.cloudone.trendmicro.com",
		"au-1": "antimalware.au-1.cloudone.trendmicro.com",
		"jp-1": "antimalware.jp-1.cloudone.trendmicro.com",
		"gb-1": "antimalware.gb-1.cloudone.trendmicro.com",
		"ca-1": "antimalware.ca-1.cloudone.trendmicro.com",
		"ae-1": "antimalware.ae-1.cloudone.trendmicro.com",
		"trend-us-1": "antimalware.trend-us-1.cloudone.trendmicro.com"
		}`

	mapping := map[string]string{}
	json.Unmarshal([]byte(mappingJSON), &mapping)

	fqdn := mapping[targetRegion]
	return fqdn
}

//////////////////////////////////////
//
// Logging and error related functions
//
//////////////////////////////////////

func getLogLevel() LogLevel {
	envLogLevel := os.Getenv(_envvarLogLevel)
	if envLogLevel != "" {
		if val, err := strconv.Atoi(envLogLevel); err == nil {
			return LogLevel(val)
		}
	}
	return LogLevelOff
}

var level2strMap = map[LogLevel]string{
	LogLevelOff:     "OFF",
	LogLevelFatal:   "FATAL",
	LogLevelError:   "ERROR",
	LogLevelWarning: "WARNING",
	LogLevelInfo:    "INFO",
	LogLevelDebug:   "DEBUG",
}

func logMsg(level LogLevel, format string, a ...interface{}) {

	// This function never be invoked with level = LogLevelOff
	if level <= LogLevelOff {
		log.Panicf("[%s] logMsg() invoked with level = LogLevelOff and format = %s",
			level2strMap[LogLevelWarning], format)
	}

	if level <= currentLogLevel {
		levelStr := level2strMap[level]
		if userLogger != nil {
			userLogger(level, levelStr, format, a...)
		} else {
			format = fmt.Sprintf("[%s] %s", levelStr, format)
			log.Printf(format, a...)
		}
	}
}

func makeFailedScanJSONResp() string {
	// Only failed a scan completes successfully will the returned JSON response be valid,
	// so a failed scan response can be anything, so just return empty string for now.

	return ""
}

func makeInternalError(msg string) error {
	return status.Error(codes.Internal, msg)
}

func sanitizeGRPCError(err error) error {

	st, _ := status.FromError(err)

	// The following codes are based on https://pkg.go.dev/google.golang.org/grpc/codes#section-sourcefiles

	logMsg(LogLevelDebug, "Received gRPC status code: %d, msg: %s", st.Code(), st.Message())

	switch st.Code() {

	// OK is returned on success.
	case codes.OK:

	// Canceled indicates the operation was canceled (typically by the caller).
	//
	// The gRPC framework will generate this error code when cancellation
	// is requested.
	case codes.Canceled:

	// Unknown error. An example of where this error may be returned is
	// if a Status value received from another address space belongs to
	// an error-space that is not known in this address space. Also
	// errors raised by APIs that do not return enough error information
	// may be converted to this error.
	//
	// The gRPC framework will generate this error code in the above two
	// mentioned cases.
	case codes.Unknown:

		return status.Error(st.Code(), "Ecountered an unknown error")

	// InvalidArgument indicates client specified an invalid argument.
	// Note that this differs from FailedPrecondition. It indicates arguments
	// that are problematic regardless of the state of the system
	// (e.g., a malformed file name).
	//
	// This error code will not be generated by the gRPC framework.
	case codes.InvalidArgument: /* NOT GENERATED BY THE GRPC FRAMEWORK */

	// DeadlineExceeded means operation expired before completion.
	// For operations that change the state of the system, this error may be
	// returned even if the operation has completed successfully. For
	// example, a successful response from a server could have been delayed
	// long enough for the deadline to expire.
	//
	// The gRPC framework will generate this error code when the deadline is
	// exceeded.
	case codes.DeadlineExceeded:

	// NotFound means some requested entity (e.g., file or directory) was
	// not found.
	//
	// This error code will not be generated by the gRPC framework.
	case codes.NotFound: /* NOT GENERATED BY THE GRPC FRAMEWORK */

	// AlreadyExists means an attempt to create an entity failed because one
	// already exists.
	//
	// This error code will not be generated by the gRPC framework.
	case codes.AlreadyExists: /* NOT GENERATED BY THE GRPC FRAMEWORK */

	// PermissionDenied indicates the caller does not have permission to
	// execute the specified operation. It must not be used for rejections
	// caused by exhausting some resource (use ResourceExhausted
	// instead for those errors). It must not be
	// used if the caller cannot be identified (use Unauthenticated
	// instead for those errors).
	//
	// This error code will not be generated by the gRPC core framework,
	// but expect authentication middleware to use it.
	case codes.PermissionDenied: /* NOT GENERATED BY THE GRPC FRAMEWORK */

		return status.Error(st.Code(), "API key does not have permission to access the service")

	// ResourceExhausted indicates some resource has been exhausted, perhaps
	// a per-user quota, or perhaps the entire file system is out of space.
	//
	// This error code will be generated by the gRPC framework in
	// out-of-memory and server overload situations, or when a message is
	// larger than the configured maximum size.
	case codes.ResourceExhausted:

	// FailedPrecondition indicates operation was rejected because the
	// system is not in a state required for the operation's execution.
	// For example, directory to be deleted may be non-empty, an rmdir
	// operation is applied to a non-directory, etc.
	//
	// A litmus test that may help a service implementor in deciding
	// between FailedPrecondition, Aborted, and Unavailable:
	//  (a) Use Unavailable if the client can retry just the failing call.
	//  (b) Use Aborted if the client should retry at a higher-level
	//      (e.g., restarting a read-modify-write sequence).
	//  (c) Use FailedPrecondition if the client should not retry until
	//      the system state has been explicitly fixed. E.g., if an "rmdir"
	//      fails because the directory is non-empty, FailedPrecondition
	//      should be returned since the client should not retry unless
	//      they have first fixed up the directory by deleting files from it.
	//  (d) Use FailedPrecondition if the client performs conditional
	//      REST Get/Update/Delete on a resource and the resource on the
	//      server does not match the condition. E.g., conflicting
	//      read-modify-write on the same resource.
	//
	// This error code will not be generated by the gRPC framework.
	case codes.FailedPrecondition: /* NOT GENERATED BY THE GRPC FRAMEWORK */

	// Aborted indicates the operation was aborted, typically due to a
	// concurrency issue like sequencer check failures, transaction aborts,
	// etc.
	//
	// See litmus test above for deciding between FailedPrecondition,
	// Aborted, and Unavailable.
	//
	// This error code will not be generated by the gRPC framework.
	case codes.Aborted: /* NOT GENERATED BY THE GRPC FRAMEWORK */

	// OutOfRange means operation was attempted past the valid range.
	// E.g., seeking or reading past end of file.
	//
	// Unlike InvalidArgument, this error indicates a problem that may
	// be fixed if the system state changes. For example, a 32-bit file
	// system will generate InvalidArgument if asked to read at an
	// offset that is not in the range [0,2^32-1], but it will generate
	// OutOfRange if asked to read from an offset past the current
	// file size.
	//
	// There is a fair bit of overlap between FailedPrecondition and
	// OutOfRange. We recommend using OutOfRange (the more specific
	// error) when it applies so that callers who are iterating through
	// a space can easily look for an OutOfRange error to detect when
	// they are done.
	//
	// This error code will not be generated by the gRPC framework.
	case codes.OutOfRange: /* NOT GENERATED BY THE GRPC FRAMEWORK */

	// Unimplemented indicates operation is not implemented or not
	// supported/enabled in this service.
	//
	// This error code will be generated by the gRPC framework. Most
	// commonly, you will see this error code when a method implementation
	// is missing on the server. It can also be generated for unknown
	// compression algorithms or a disagreement as to whether an RPC should
	// be streaming.
	case codes.Unimplemented:

		return status.Error(st.Code(), "Client SDK not compatible with the Anti-malware  Service - please upgrade")

	// Internal errors. Means some invariants expected by underlying
	// system has been broken. If you see one of these errors,
	// something is very broken.
	//
	// This error code will be generated by the gRPC framework in several
	// internal error conditions.
	case codes.Internal:

	// Unavailable indicates the service is currently unavailable.
	// This is a most likely a transient condition and may be corrected
	// by retrying with a backoff. Note that it is not always safe to retry
	// non-idempotent operations.
	//
	// See litmus test above for deciding between FailedPrecondition,
	// Aborted, and Unavailable.
	//
	// This error code will be generated by the gRPC framework during
	// abrupt shutdown of a server process or network connection.
	case codes.Unavailable:

		desc := st.Message()

		if strings.Contains(desc, "transport: authentication handshake failed: x509") {
			return status.Error(codes.Internal, "Server certificate verification failed")
		} else if strings.Contains(desc, "http2: frame too large") {
			return status.Error(codes.Internal, "Use of TLS for client-server communication required but not detected")
		}

		return status.Error(st.Code(), "Anti-Malware Service is not reachable")

	// DataLoss indicates unrecoverable data loss or corruption.
	//
	// This error code will not be generated by the gRPC framework.
	case codes.DataLoss: /* NOT GENERATED BY THE GRPC FRAMEWORK */

	// Unauthenticated indicates the request does not have valid
	// authentication credentials for the operation.
	//
	// The gRPC framework will generate this error code when the
	// authentication metadata is invalid or a Credentials callback fails,
	// but also expect authentication middleware to generate it.
	case codes.Unauthenticated:

		return status.Error(st.Code(), "Authorization key cannot be authenticated")
	}

	return status.Error(codes.Internal, st.Message())
}

//////////////////////////////////////////////////////////////
//
// Publicly unsupported API provided for legacy internal tools
//
//////////////////////////////////////////////////////////////

func NewClientInternal(key string, addr string, useTLS bool) (*AmaasClient, error) {

	ac := &AmaasClient{}

	ac.authKey = key
	ac.addr = addr
	ac.useTLS = useTLS
	ac.verifyCert = false

	var err error

	if ac.timeoutSecs, err = getDefaultScanTimeout(); err != nil {
		return nil, err
	}

	if err = ac.archHandler.initHandler(ac); err != nil {
		return nil, err
	}

	if err = ac.setupComm(); err != nil {
		return nil, err
	}

	return ac, nil
}
