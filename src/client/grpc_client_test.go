package client

import (
	"context"
	"fmt"
	"github.com/stretchr/testify/assert"
	"os"
	"testing"
)

//
// API key related tests
//

func TestCheckAuthKeyEmpty(t *testing.T) {

	os.Setenv(_envvarAuthKey, "")
	os.Setenv(_envvarAuthKeyNotRequired, "")

	key, err := checkAuthKey("")

	assert.NotNil(t, err)
	assert.Equal(t, "", key)

	// Set TM_AM_AUTH_KEY_NOT_REQUIRED to "0" has same effect as empty
	os.Setenv(_envvarAuthKeyNotRequired, "0")

	key, err = checkAuthKey("")

	assert.NotNil(t, err)
	assert.Equal(t, "", key)
}

func TestCheckAuthKeyEmptyWithOverride(t *testing.T) {

	os.Setenv(_envvarAuthKey, "")
	os.Setenv(_envvarAuthKeyNotRequired, "1")

	key, err := checkAuthKey("")

	assert.Nil(t, err)
	assert.Equal(t, "", key)
}

const someInvalidKey = "eyblahblahblah.eydsfdfdfdf.EYhhhhhhhhhhhhhh"
const someAPIKey = "tmc12HqBqc6l73N6BVeALskdO2YFbUe:3LM4rSoukHvGbe1FQa6xeXLCQkyqcUNe8zBs9tn3u7uPHgGNsu9SqAgVV9Ri1WsBcL"
const someJWT = "eyJhbGciOiJSUzI1NiIsImtpZCI6Ijk4NjhiMTE5LWM4Y2MtNDNiMS05NGE3LTk4NTU2MDQ3NjRjYyIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJ0cmVuZC11cy0xLmNsb3Vkb25lLnRyZW5kbWljcm8uY29tIiwiZXhwIjoxNjczMzAwNzMwLCJqdGkiOiIySzZnUVlsaTF2dGFkNXhZSEF1emwxbFlZcW0iLCJpYXQiOjE2NzMzMDA0MzAsImlzcyI6ImFjY291bnRzLnRyZW5kLXVzLTEuY2xvdWRvbmUudHJlbmRtaWNyby5jb20iLCJjbG91ZE9uZSI6eyJwcmluY2lwYWwiOnsiYWNjb3VudCI6IjI2OTExNjAzNTM5NyIsInJvbGUiOiJ1cm46Y2xvdWRvbmU6aWRlbnRpdHk6dHJlbmQtdXMtMToyNjkxMTYwMzUzOTc6cm9sZS9mdWxsLWFjY2VzcyIsInR5cGUiOiJ1c2VyIiwidXJuIjoidXJuOmNsb3Vkb25lOmlkZW50aXR5OnRyZW5kLXVzLTE6MjY5MTE2MDM1Mzk3OnVzZXIvODE4ZmRjNzQtYTE3Zi00OGVkLWFmYjQtOWM4ZGJiZGExNGU1IiwibWZhIjpmYWxzZX19LCJsb2NhbGUiOiJlbiIsImFjY291bnRMb2NhbGUiOiJlbiIsInRpbWV6b25lIjoiQW1lcmljYS9Mb3NfQW5nZWxlcyIsImFjY291bnRUaW1lem9uZSI6IkFtZXJpY2EvTG9zX0FuZ2VsZXMiLCJvcmlnaW5fanRpIjoiOTA3ZTgyZmMtMjQyYy00YmU5LTlmMDgtMzU5NDI1MTg3NDZhIn0.snYR-3tb6ICFa3mC3ulpkXKMiZ1s8wrZ7gPrFIo5WaN_q0-AIFCqXGhsD1jpCyfjI2ymFcYnrjcuSR9WwGfFhXMs0nSDsQULt0jm81Ociv5Ucr9SNYCGG1qUhbbV3cO6aqYVQqjuqslMbiyJBGObc5L70IyYq8L9I8cQRDepg6bdwurHgU5BGDseMEcjCaxOZvDd0M08XLcynw_172jMUPhjdw04vFr0aJaU1PoWDBBwbxgWBTX8bczFI1MONmnTiVse0rJ0i9xB_e6BbRUpjaCVNWxOJdgPOSLrJSC1xeNuekTJ2j6scvdQOQRmDvt16y9K4amEITdEt8xRBDQ9DJaAMYmpp24XHETXk-wTUr6xDzuod5ckjcsooF79r1CIQGGT1N8bWYVbQx1iqhUNZHLOVKzMWaW1C2SkslteUhppOZhVRVgxm3bRAVaVsrFHHt51mT8cNOBfXY8s20MNsqNJ3j1P3A4X18IhZKsvu0dIRV4h4jYvpVheCYNR4SCTz2fECwW-EcgPzedfcgVupGXpQNIKRe0gjJUVMP_iDCyi-0mVT70wjKhIWxrJ085Al_8FKQKQ9W5Wlg0TbkEJYlYdVLn5WC0zB1gLsG66D2kEsWmbedZ8iJ1xhCog_mEdy1Ns4xkNnK_voilZsWyltvKA2-3oHhdR-peIxU5CMgA"

func TestCheckAuthKeyNonEmptyInvalid(t *testing.T) {

	os.Setenv(_envvarAuthKey, "")
	os.Setenv(_envvarAuthKeyNotRequired, "")

	key, err := checkAuthKey(someInvalidKey)

	assert.NotNil(t, err)
	assert.Equal(t, "", key)
}

func TestCheckAuthKeyNonEmptyValidAPIKey(t *testing.T) {

	os.Setenv(_envvarAuthKey, "")
	os.Setenv(_envvarAuthKeyNotRequired, "")

	key, err := checkAuthKey(someAPIKey)

	assert.Nil(t, err)
	assert.Equal(t, someAPIKey, key)
}

func TestCheckAuthKeyNonEmptyValidJWT(t *testing.T) {

	os.Setenv(_envvarAuthKey, "")
	os.Setenv(_envvarAuthKeyNotRequired, "")

	key, err := checkAuthKey(someJWT)

	assert.Nil(t, err)
	assert.Equal(t, someJWT, key)
}

func TestCheckAuthKeyNonEmptyEnvVarOverride(t *testing.T) {

	const someEnvVarSetAuthKey = someJWT

	os.Setenv(_envvarAuthKey, someEnvVarSetAuthKey)
	os.Setenv(_envvarAuthKeyNotRequired, "")

	const someKey = "some-string-as-api-key"
	key, err := checkAuthKey(someKey)

	assert.Nil(t, err)
	assert.Equal(t, someEnvVarSetAuthKey, key)

	// Set TM_AM_AUTH_KEY_NOT_REQUIRED to "0" has same effect as empty
	os.Setenv(_envvarAuthKeyNotRequired, "0")

	key, err = checkAuthKey(someKey)

	assert.Nil(t, err)
	assert.Equal(t, someEnvVarSetAuthKey, key)
}

//
// Service FQDN related tests
//

func TestGetServiceFQDNEmpty(t *testing.T) {

	fqdn := getServiceFQDN("")
	assert.Equal(t, "", fqdn)
}

func TestGetServiceFQDNGarbage(t *testing.T) {

	fqdn := getServiceFQDN("blah blah okay")
	assert.Equal(t, "", fqdn)
}

func TestGetServiceFQDNMapping(t *testing.T) {

	var inputs = []string{
		"us-1",
		"in-1",
		"de-1",
		"sg-1",
		"au-1",
		"jp-1",
		"gb-1",
		"ca-1",
		"ae-1",
		"trend-us-1",
	}

	for _, region := range inputs {
		expected := fmt.Sprintf("antimalware.%s.cloudone.trendmicro.com", region)
		fqdn := getServiceFQDN(region)

		assert.Equal(t, expected, fqdn)
	}
}

//
// Server address retrieval related tests
//

func TestIdServerAddressEmpty(t *testing.T) {

	os.Setenv(_envvarServerAddr, "")

	addr, err := identifyServerAddr("")

	assert.NotNil(t, err)
	assert.Equal(t, "", addr)
}

func TestIdServerAddressEmptyWithOverride(t *testing.T) {

	const testAddr = "this.is.a.fake.server.address:123"
	os.Setenv(_envvarServerAddr, testAddr)

	addr, err := identifyServerAddr("")

	assert.Nil(t, err)
	assert.Equal(t, testAddr, addr)
}

func TestIdServerAddressGarbage(t *testing.T) {

	os.Setenv(_envvarServerAddr, "")

	addr, err := identifyServerAddr("blah blah blah")

	assert.NotNil(t, err)
	assert.Equal(t, "", addr)
}

func TestIdServerAddressValid(t *testing.T) {

	os.Setenv(_envvarServerAddr, "")

	addr, err := identifyServerAddr("us-1")

	expected := fmt.Sprintf("%s:%d", getServiceFQDN("us-1"), _defaultCommPort)

	assert.Nil(t, err)
	assert.Equal(t, expected, addr)
}

func TestIdServerAddressValidWithOverride(t *testing.T) {

	const testAddr = "this.is.a.fake.server.address:123"
	os.Setenv(_envvarServerAddr, testAddr)

	addr, err := identifyServerAddr("us-1")

	assert.Nil(t, err)
	assert.Equal(t, testAddr, addr)
}

//
// TLS settings related tests
//

func TestRetrieveTLSSettings(t *testing.T) {

	os.Setenv(_envvarDisableTLS, "")
	os.Setenv(_envvarDisableCertVerify, "")

	useTLS, verifyCert := retrieveTLSSettings()

	assert.Equal(t, true, useTLS)
	assert.Equal(t, true, verifyCert)

	os.Setenv(_envvarDisableTLS, "0")
	os.Setenv(_envvarDisableCertVerify, "0")

	useTLS, verifyCert = retrieveTLSSettings()

	assert.Equal(t, true, useTLS)
	assert.Equal(t, true, verifyCert)

	os.Setenv(_envvarDisableTLS, "1")
	os.Setenv(_envvarDisableCertVerify, "1")

	useTLS, verifyCert = retrieveTLSSettings()

	assert.Equal(t, false, useTLS)
	assert.Equal(t, false, verifyCert)
}

//
// Scan timeout related tests
//

func TestGetDefaultScanTimeout(t *testing.T) {

	os.Setenv(_envvarScanTimeoutSecs, "")

	timeout, err := getDefaultScanTimeout()

	assert.Nil(t, err)
	assert.Equal(t, _defaultTimeoutSecs, timeout)
}

func TestGetDefaultScanTimeoutWithOverride(t *testing.T) {

	os.Setenv(_envvarScanTimeoutSecs, "what-the-heck")

	timeout, err := getDefaultScanTimeout()

	assert.NotNil(t, err)

	os.Setenv(_envvarScanTimeoutSecs, "1000")

	timeout, err = getDefaultScanTimeout()

	assert.Nil(t, err)
	assert.Equal(t, 1000, timeout)

	os.Setenv(_envvarScanTimeoutSecs, "123")

	timeout, err = getDefaultScanTimeout()

	assert.Nil(t, err)
	assert.Equal(t, 123, timeout)
}

//
// Logging facility related tests
//

func TestLogMsgWithNonOffLevel(t *testing.T) {

	triggered := false

	defer func() {
		triggered = true
	}()

	logMsg(LogLevelFatal, "TestLogMsgWithNonOffLevel: LogLevelFatal")
	logMsg(LogLevelError, "TestLogMsgWithNonOffLevel: LogLevelError")
	logMsg(LogLevelWarning, "TestLogMsgWithNonOffLevel: LogLevelWarning")
	logMsg(LogLevelInfo, "TestLogMsgWithNonOffLevel: LogLevelInfo")
	logMsg(LogLevelDebug, "TestLogMsgWithNonOffLevel: LogLevelDebug")

	assert.Equal(t, false, triggered)
}

func TestLogMsgWithOffLevel(t *testing.T) {

	triggered := false

	defer func() {
		triggered = true

		r := recover()
		assert.NotNil(t, r)
	}()

	logMsg(LogLevelOff, "TestLogMsgWithNonOffLevel: LogLevelOff")

	assert.Equal(t, true, triggered)
}

var CBTriggeredFlag bool = false

func LoggingCallback(level LogLevel, levelStr string, format string, a ...interface{}) {
	CBTriggeredFlag = true
}

func TestLoggingWithErrort(t *testing.T) {

	ConfigLoggingCallback(LoggingCallback)

	CBTriggeredFlag = false

	ctx, cancel := context.WithTimeout(context.Background(), 0)

	// With log level at OFF, callback should NOT be triggered
	// even when there is an error from a file open failure.

	SetLoggingLevel(LogLevelOff)
	fileScanRun(ctx, cancel, nil, "bad-filepath-sdjfdjfdkf")
	assert.Equal(t, false, CBTriggeredFlag)

	// With log level at FATAL, callback should NOT be triggered
	// even when there is an error from a file open failure.

	SetLoggingLevel(LogLevelFatal)
	fileScanRun(ctx, cancel, nil, "bad-filepath-sdjfdjfdkf")
	assert.Equal(t, false, CBTriggeredFlag)

	// With log level at ERROR, callback should be triggered
	// when there is an error from a file open failure.

	SetLoggingLevel(LogLevelError)
	fileScanRun(ctx, cancel, nil, "bad-filepath-sdjfdjfdkf")
	assert.Equal(t, true, CBTriggeredFlag)

	CBTriggeredFlag = false

	// With log level at ERROR, callback should  be triggered
	// when there is an error from a file open failure.

	SetLoggingLevel(LogLevelWarning)
	fileScanRun(ctx, cancel, nil, "bad-filepath-sdjfdjfdkf")
	assert.Equal(t, true, CBTriggeredFlag)

	CBTriggeredFlag = false

	// With log level at INFO, callback should  be triggered
	// when there is an error from a file open failure.

	SetLoggingLevel(LogLevelInfo)
	fileScanRun(ctx, cancel, nil, "bad-filepath-sdjfdjfdkf")
	assert.Equal(t, true, CBTriggeredFlag)
}

func TestLoggingWithNonDebugLevel(t *testing.T) {

	if os.Getenv("CI") != "" {
		t.Skip("Skipping this test in slower CI environment")
	}

	ConfigLoggingCallback(LoggingCallback)

	CBTriggeredFlag = false

	// With log level at OFF, callback should not be triggered.

	SetLoggingLevel(LogLevelOff)
	TestRunUploadLoopNormal(t)
	assert.Equal(t, false, CBTriggeredFlag)

	// With log level at FATAL, callback should not be triggered.

	SetLoggingLevel(LogLevelFatal)
	TestRunUploadLoopNormal(t)
	assert.Equal(t, false, CBTriggeredFlag)

	// With log level at ERROR, callback should not be triggered.

	SetLoggingLevel(LogLevelError)
	TestRunUploadLoopNormal(t)
	assert.Equal(t, false, CBTriggeredFlag)

	// With log level at WARNING, callback should not be triggered.

	SetLoggingLevel(LogLevelWarning)
	TestRunUploadLoopNormal(t)
	assert.Equal(t, false, CBTriggeredFlag)

	// With log level at INFO, callback should not be triggered.

	SetLoggingLevel(LogLevelInfo)
	TestRunUploadLoopNormal(t)
	assert.Equal(t, false, CBTriggeredFlag)
}

func TestLoggingWithDebugLevel(t *testing.T) {

	if os.Getenv("CI") != "" {
		t.Skip("Skipping this test in slower CI environment")
	}

	ConfigLoggingCallback(LoggingCallback)
	CBTriggeredFlag = false

	// Callback should only be triggered when level is at DEBUG

	SetLoggingLevel(LogLevelDebug)
	TestRunUploadLoopNormal(t)
	assert.Equal(t, true, CBTriggeredFlag)
}
